* * *

layout:     post
title: 队列实现插入、弹出
category: blog

## description: 找到最小值   

先来个简单的栈(先进后出)

#### 题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）.

> ### 常见想法：
> 
>      <span class="hljs-number">1.</span>创建一个整型变量 <span class="hljs-built_in">min</span>，初始值 -<span class="hljs-number">1</span>
>      <span class="hljs-number">2.</span>当第一个元素进栈时，让 <span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>，即把第一个元素当做最小值。
>      <span class="hljs-number">3.</span>之后每当一个新元素进栈，让新元素和 <span class="hljs-built_in">min</span>指向位置的元素比较大小。如果Stack[<span class="hljs-built_in">min</span>]大于新元素，则 <span class="hljs-built_in">min</span>等于新元素的下标。反之则不做改变。
>      <span class="hljs-number">4.</span>当调用getMin方法的时候，直接返回 <span class="hljs-built_in">min</span>所指向位置的元素即可。
>     `</pre>

    但这样子会出现一个问题，那就是这个最小元素出栈后，就没有“备胎”了。

    > ### 解法：
> 
>     <pre>`<span class="hljs-number">1</span>.设原有的栈叫做<span class="hljs-literal">A</span>栈，此时在创建一个额外的栈B，用于辅助原栈<span class="hljs-literal">A</span>。
>     <span class="hljs-number">2</span>.当第一个元素进入栈<span class="hljs-literal">A</span>的时候，让新元素的下标进入栈B。这个唯一的元素是栈<span class="hljs-literal">A</span>的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是<span class="hljs-literal">A</span>栈元素的下标）
>     <span class="hljs-number">3</span>.每当新元素进入栈<span class="hljs-literal">A</span>时，比较新元素和栈<span class="hljs-literal">A</span>当前最小值的大小，如果小于栈<span class="hljs-literal">A</span>当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈<span class="hljs-literal">A</span>当前最小值的下标。
>     <span class="hljs-number">4</span>.每当栈<span class="hljs-literal">A</span>有元素出栈时，如果出栈元素是栈<span class="hljs-literal">A</span>当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈<span class="hljs-literal">A</span>当中原本第二小的元素，代替刚才的出栈元素成为了栈<span class="hljs-literal">A</span>的当前最小值。（备胎转正）
>     <span class="hljs-number">5</span>.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈<span class="hljs-literal">A</span>对应元素即可。
>     `</pre>

    现在回归更难一点的队列(先进先出)问题

    #### 实现一个队列，带有出队（deQueue），入队（enQueue），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。

    对于队列我们可以照葫芦画瓢

    > ### 解法：
> 
>     <pre>`<span class="hljs-number">1</span>.设原有的队列叫做<span class="hljs-literal">A</span>队列，此时创建一个_双端队列_B，用于辅助队列<span class="hljs-literal">A</span>
>     <span class="hljs-number">2</span>.当第一个元素进入队列<span class="hljs-literal">A</span>的时候，让元素的下标进入队列B。这个唯一的元素是队列<span class="hljs-literal">A</span>的当前最小值。
>     <span class="hljs-number">3</span>.每当新元素进入队列<span class="hljs-literal">A</span>时，比较新元素与当前队列B中最后一个元素所存下标指定的元素的值，如果新元素小于指定元素，对其进行出队操作。循环执行知道发现指定元素小于新元素或者该队列为空时。将该新元素的下标入队。
>     <span class="hljs-number">4</span>.每当队列<span class="hljs-literal">A</span>有元素出队时，判断该元素是否有对应的队列B下标的存储，有则相应进行出队操作。此时队列B 对头的元素就是原本第二小的元素代替刚才出队的元素成为了队列<span class="hljs-literal">A</span>的当前最小值。
>     <span class="hljs-number">5</span>.当调用getMin方法时，直接返回队列B对头所指向的队列<span class="hljs-literal">A</span>所对应的元素即可。
>     `</pre><pre>`注：双端队列就是限定插入和删除操作在表的两端进行的线性表。即前后两个端点都可以进行出队、入队操作。