---
layout:     post
title: 队列实现插入、弹出
category: blog
description: 找到最小值   
---
先来个简单的栈(先进后出)

#### 题目：实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）.

> ### 常见想法：
> 1.创建一个整型变量 min，初始值 -1  
> 2.当第一个元素进栈时，让 min=0，即把第一个元素当做最小值。  
> 3.之后每当一个新元素进栈，让新元素和 min指向位置的元素比较大小。如果Stack[min]大于新元素，则 min等于新元素的下标。反之则不做改变。  
> 4.当调用getMin方法的时候，直接返回 min所指向位置的元素即可。  

但这样子会出现一个问题，那就是这个最小元素出栈后，就没有“备胎”了。

> ### 解法：
> 1.设原有的栈叫做A栈，此时在创建一个额外的栈B，用于辅助原栈A。  
> 2.当第一个元素进入栈A的时候，让新元素的下标进入栈B。这个唯一的元素是栈A的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是A栈元素的下标）  
> 3.每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈A当前最小值的下标。  
> 4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第二小的元素，代替刚才的出栈元素成为了栈A的当前最小值。（备胎转正）  
> 5.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈A对应元素即可。

现在回归更难一点的队列(先进先出)问题

#### 实现一个队列，带有出队（deQueue），入队（enQueue），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。

对于队列我们可以照葫芦画瓢

> ### 解法：
> 1.设原有的队列叫做A队列，此时创建一个_双端队列_B，用于辅助队列A  
> 2.当第一个元素进入队列A的时候，让元素的下标进入队列B。这个唯一的元素是队列A的当前最小值。  
> 3.每当新元素进入队列A时，比较新元素与当前队列B中最后一个元素所存下标指定的元素的值，如果新元素小于指定元素，对其进行出队操作。循环执行知道发现指定元素小于新元素或者该队列为空时。将该新元素的下标入队。  
> 4.每当队列A有元素出队时，判断该元素是否有对应的队列B下标的存储，有则相应进行出队操作。此时队列B 对头的元素就是原本第二小的元素代替刚才出队的元素成为了队列A的当前最小值。  
> 5.当调用getMin方法时，直接返回队列B对头所指向的队列A所对应的元素即可。  
```
注：双端队列就是限定插入和删除操作在表的两端进行的线性表。即前后两个端点都可以进行出队、入队操作。  
```